# -*- coding: utf-8 -*-
"""ML_version2_finale.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11C7Tt3Y1OqXKU7DavAWAqth75jwnIvzW
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

#Importing libraries.
from sklearn.model_selection import train_test_split, StratifiedKFold, GridSearchCV
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.pipeline import make_pipeline
from sklearn.tree import DecisionTreeClassifier
from sklearn.feature_selection import SelectKBest, f_classif
from sklearn.linear_model import LinearRegression, Ridge, Lasso, ElasticNet
from sklearn.preprocessing import PolynomialFeatures, StandardScaler

# Commented out IPython magic to ensure Python compatibility.
# Core
import numpy as np
import pandas as pd
pd.plotting.register_matplotlib_converters()
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
sns.set(style='darkgrid', font_scale=1.4)
import plotly.express as px

# Sklearn
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
# UMAP
import umap
import umap.plot

import pandas as pd
import os
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_auc_score
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
import numpy as np
from sklearn.metrics import confusion_matrix
from matplotlib import pyplot as plt
from seaborn import heatmap

dataset = pd.read_excel('/content/Base de donnees greffe pulmonaire_Ian.xlsx')

dataset = dataset.drop(['Unnamed: 0', 'NIP (identifiant)', 'date de TP','mortalité à 90j','mortalité à J30'], axis = 1)

dataset = dataset.fillna(dataset.mean())

X= dataset.drop(labels = "mortalité à un an", axis = 1)
labels= dataset["mortalité à un an"]

# This scales each column to have mean=0 and standard deviation=1
scaler = StandardScaler()
greffe_scaler = scaler.fit_transform(X)
# Apply scaling
df=pd.DataFrame(greffe_scaler, columns=X.columns)

X_train, X_test, y_train, y_test = train_test_split(
df, labels, stratify=labels, random_state=42, shuffle = True)



"""## 1 RandomForestClassifier"""

param_grid = [{'n_estimators': [50, 500, 5000]}]
rnd_clf = RandomForestClassifier()
grid_search = GridSearchCV(rnd_clf, param_grid, cv=10, scoring='accuracy', n_jobs=-1, verbose=3)
grid_search.fit(X_train, y_train)

grid_search.best_estimator_

y_pred_rf = grid_search.predict(X_test)
accuracy_score(y_test, y_pred_rf)

roc_auc_score(y_test, y_pred_rf)

pd.DataFrame(y_pred_rf).describe()

tn, fp, fn, tp = confusion_matrix(y_test, y_pred_rf).ravel()
ax= plt.subplot()
heatmap([[tn, fp], [fn, tp]], annot=True, fmt='g', ax=ax, center=1)
ax.set_xlabel('Predicted labels');ax.set_ylabel('True labels');
ax.set_title('Confusion Matrix');
ax.xaxis.set_ticklabels(['0', '1']); ax.yaxis.set_ticklabels(['0', '1']);

"""## 2 ExtraTreesClassifier"""

param_grid = [{'n_estimators': [50, 500, 5000]}]
etc_clf = ExtraTreesClassifier()
grid_search = GridSearchCV(rnd_clf, param_grid, cv=10, scoring='accuracy', n_jobs = -1, verbose = 3)
grid_search.fit(X_train, y_train)

grid_search.best_estimator_

y_pred_etc = grid_search.predict(X_test)
accuracy_score(y_test, y_pred_etc)

roc_auc_score(y_test, y_pred_etc)

pd.DataFrame(y_pred_etc).describe()

tn, fp, fn, tp = confusion_matrix(y_test, y_pred_etc).ravel()
ax= plt.subplot()
heatmap([[tn, fp], [fn, tp]], annot=True, fmt='g', ax=ax, center=1)
ax.set_xlabel('Predicted labels');ax.set_ylabel('True labels');
ax.set_title('Confusion Matrix');
ax.xaxis.set_ticklabels(['0', '1']); ax.yaxis.set_ticklabels(['0', '1']);

"""## 3 Ridge regression"""

from sklearn.linear_model import RidgeClassifier
param_grid = [{'alpha': [0.1, 1]}]
rdg_clf = RidgeClassifier()
grid_search_rdg = GridSearchCV(rdg_clf, param_grid, cv=10, scoring='accuracy', n_jobs = -1, verbose = 3)
grid_search_rdg.fit(X_train, y_train)

grid_search_rdg.best_params_

y_pred_ridge = grid_search_rdg.predict(X_test)
accuracy_score(y_test, y_pred_ridge)

roc_auc_score(y_test, y_pred_ridge)

pd.DataFrame(y_pred_ridge).describe()

tn, fp, fn, tp = confusion_matrix(y_test, y_pred_ridge).ravel()
ax= plt.subplot()
heatmap([[tn, fp], [fn, tp]], annot=True, fmt='g', ax=ax, center=1)

ax.set_xlabel('Predicted labels');ax.set_ylabel('True labels');
ax.set_title('Confusion Matrix');
ax.xaxis.set_ticklabels(['0', '1']); ax.yaxis.set_ticklabels(['0', '1']);

"""## 4 Perceptron"""

from sklearn.linear_model import Perceptron
param_grid = [{'penalty' : ['l1'],'alpha': [0.0001, 0.001, 0.01, 0.1, 1]}]
pcp_clf = Perceptron()
grid_search_pcp = GridSearchCV(pcp_clf, param_grid, cv=10, scoring='accuracy',n_jobs = -1, verbose = 3)
grid_search_pcp.fit(X_train, y_train)

grid_search_pcp.best_params_

y_pred_perceptron = grid_search_pcp.predict(X_test)

accuracy_score(y_test, y_pred_perceptron)

roc_auc_score(y_test, y_pred_perceptron)

tn, fp, fn, tp = confusion_matrix(y_test, y_pred_perceptron).ravel()
ax= plt.subplot()
heatmap([[tn, fp], [fn, tp]], annot=True, fmt='g', ax=ax, center=1)
ax.set_xlabel('Predicted labels');ax.set_ylabel('True labels');
ax.set_title('Confusion Matrix');
ax.xaxis.set_ticklabels(['0', '1']); ax.yaxis.set_ticklabels(['0', '1']);